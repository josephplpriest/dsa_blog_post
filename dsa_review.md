# How to Ace your Next Technical Interview:
### Ten books to learn data structures and algorithms

Eventually, every new programmer will discover the terms "Data Structures" and "Algorithms". While initially confusing or intimidating, if you are doing almost any coding at all, you are already using "data structures". These are the building blocks the computer uses to store information.

### Data structure examples:
A list, array or string can be thought of as a long set of containers where each holds a different element or letter (for a string) in a distinct location.

<img src="containers.jpg" alt="drawing" width="600" height="350"/>

Photo by <a href="https://unsplash.com/@live_for_photo?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText">Teng Yuhong</a>

A dictionary or hash-table stores elements by key/hash, so that items can quickly be looked up. If asked to look up a word that starts with "aa" or "zz" in a physical dictionary, it would be very quick to find, just look at the beginning or the end!

<img src="catalog.jpg" alt="drawing" width="300"/>

Photo by <a href="https://unsplash.com/@erol?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText">Erol Ahmed</a>

There are many more complex data structures of course, often designed to quickly store or look up specific pieces of data. Facebook friends and connections can be represented as a graph. We can quickly look up how two people are related by tracing their links to other people.

<img src="graph.jpg" alt="drawing" width="600" height="350"/>

Photo by <a href="https://unsplash.com/@theshubhamdhage?utm_source=unsplash&utm_medium=referral&utm_content=creditCopyText">Shubham Dhage</a> 
  
### A simple algorithm:

"Algorithms" are a series of steps, in a specific order, to produce some output. A recipe to prepare a specific type of food would be an algorithm everyone has used.

Scrambled eggs algorithm:

1. Crack the eggs into a bowl.
2. Discard the shells in the trash.
3. Beat the eggs.
4. Heat a pan.
5. Pour eggs in pan.
6. Cook eggs.
7. Remove pan from heat
8. Plate eggs.
9. Eat eggs.
10. Wash dishes.

If we put the eggs into the pan before cracking and discarding the shells, we would have some inedible results! Order is important. Additionally, we could make our recipe algorithm quicker. We could start heating the pan before cracking and beating the eggs, doing some steps in parallel. If you're a cook, you probably know how to cracked two eggs at once in each hand (a fun party trick).

If you just want a quick recommendation, here's the TLDR:

|Audience|Best Book|
|-----|-----|
|New Programmers|[Grokking Algorithms](#)|
|Python lovers|[Data Structures and Algorithms in Python](#5-data-structures-and-algorithms-in-python)|
|Interview preppers|[Cracking the Coding Interview](#3-crack-the-coding-interview)|
|History buffs|[Structure and Interpretation of Computer Programs](#10-structure-and-interpretation-of-computer-programs)|
|Math geeks|[Introduction to Algorithms](#8-introduction-to-algorithms)|

Hopefully at this point you want to learn more. Here is a review of the best (and worst) books I've found covering data structures and algorithms.

###### (in alphabetical order)
### 1. The Algorithm Design Manual
<img style="float: right;" width=200, src="https://images.amazon.com/images/P/3030542556.jpg">
Length: Long (500-1000 pages)

Languages used: C, C++, Java

Overview: 

* **pros:** 
    * "war stories" about real-world motivations for algorithms/optimizations
    * catalog of problem types and suggestions
    * wide array of topics (both data structures and algorithms)

* **cons:** 
    * Mostly in C
    * Too few diagrams explaining problems

Difficulty: 8/10

Rating: **8/10**

### 2. Algorithmic Thinking
<img style="float: right;" width=200, src="https://images.amazon.com/images/P/1718500807.jpg">

Length: Medium (300-500 pages)

Languages used: C

Overview:

* **pros:**
    * well structured, with each chapter focusing on a problem of a different type
    * online options to grade your solutions
    * clear, clean C code provided

* **cons:**
    * the topical nature means some topics don't get touched
    * because it's C only, you have to create your own data structures (hashmaps anyone?)

Difficulty: 7.5 (because C)

Rating: **6/10** (narrow audience, though the content is quite good)

### 3. Crack the Coding Interview
<img style="float: right;" width=200, src="https://images.amazon.com/images/P/0984782850.jpg">

Length: Long (500-1000 pages)

Languages used: C, C++ and Java

Overview:

* **pros:**
    * widest array of non-DSA topics (resume tips, SQL, testing, and more)
    * good coverage of algorithmic complexity/big O notation
    * explanations and solutions are top-notch
* **cons:**
    * no python or javascript
    * a new edition would be nice 

Difficulty: 6/10

Rating: 8.5/10 (well regarded for a reason)

### 4. Data Structures Demystified
<img style="float: right;" width=200, src="https://images.amazon.com/images/P/B0012OYBWG.jpg">

Length: Short (under 300 pages)

Languages used: C++, Java

Overview:

* **pros:**
    * nice explanation of low-level memory-allocation
* **cons:**
    * pages and pages of code with little explanation
    * poorly organized
    * no coverage at all of algorithmic complexity/big O notation

Difficulty: 7/10 (poor problem explanations)

Rating: 3/10

### 5. Data Structures and Algorithms in Python
<img style="float: right;" width=200, src="https://images.amazon.com/images/P/1118290275.jpg">

Length: Long (500-1000 pages)

Languages used: Python, pseudo-code

Overview:

* **pros:**
    * very comprehensive
    * lots of practice problems
* **cons:**
    * only python (tiny bit of javascript maybe)

Difficulty: 8/10

Rating: 9.5/10 (python bias, but seriously a great book)

### 6. Dive into Algorithms
<img style="float: right;" width=200, src="https://images.amazon.com/images/P/1718500688.jpg">

Length: Medium (300-500 pages)

Languages used: python

Overview: 

* **pros:**
    * best travelling salesman problem explanation 
    * nice conversational writing
    * fun, interesting problems
* **cons:**
    * jumps around topically
    * not much coverage of data structures

Difficulty: 7/10

Rating: 7/10


### 7. Grokking Algorithms
<img style="float: right;" width=200, src="https://images.amazon.com/images/P/1617292230.jpg">

Languages used: python, pseudo-code

Overview:

* **pros:**
    * wonderfully expressive diagrams
    * best introduction to the topic
    * well-thought out explanations
* **cons:**
    * short
    * does not cover many topics because of the length

Difficulty: 4/10

Rating: 9/10

### 8. Introduction to Algorithms
<img style="float: right;" width=200, src="https://images.amazon.com/images/P/0262033844.jpg">

Length: Long (500-1000 pages)

Languages used: math, some pseudo-code

Overview:

* **pros:**
    * lots of mathematical proofs
    * excellent coverage of runtime complexity/big O notation
    * could kill a burglar with this
    * good doorstop
* **cons:**
    * lots of mathematical proofs
    * explanations are often lacking
    * pseudo-code only
    * upper-level undergrad/graduate-focused text

Difficulty: 9/10

Rating: 6.5/10 (personal anti-math bias)

### 9. The Recursive Book of Recursion
<img style="float: right;" width=200, src="https://images.amazon.com/images/P/1718502028.jpg">

Length: Medium (300-500 pages)

Languages used: python, javascript

Overview:

* **pros:**
    * great explanations of recursion!
    * both python and javascript code provided for most problems
    * a gentle introduction to the topic

* **cons:**
    * does not cover data structures
    * does not cover a wide array of problems due to the narrow focus


Difficulty: 6/10 (recursion is still tough!)

Rating: **8/10**

### 10. Structure and Interpretation of Computer Programs
<img style="float: right;" width=200, src="https://images.amazon.com/images/P/0262510871.jpg">

Length: Long (500-1000 pages)

Languages used: LISP, pseudo-code

Overview:

* **pros:**
    * the OG of modern programming texts
    * good to learn the background of modern languages
    * practice problems galore
    * often reads similar to algebraic notation

* **cons:**
    * quite long
    * some topics are less relevant now
    * LISP
    * if you don't like parentheses, not recommended :-)

Difficulty: 8/10 (partly due to having to learn LISP)

Rating: **9/10** (a classic for a reason)